package com.jusfoun.timepumpingdemo;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.ValueAnimator;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.LinearInterpolator;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

/**
 * @author zhaoyapeng
 * @version create time:16/1/7上午11:17
 * @Email zyp@jusfoun.com
 * @Description ${TODO}
 */
public class TimePumpingEntity {

    public static final int TYPE_LINE = 0;
    public static final int TYPE_IMAGE = 1;
    private float maxY;
    private int imgWidth = 0;
    private int imgHeight = 0;
    //    private ImageView imageView = null;
    private int initX, initY;
    private Context mContext;
    private int offsetHeight = 0;
    private int screenWidth = 0;//屏幕宽度
    private int screenHeight = 0;//屏幕高度
    private TimePumpingView layout;

    private float currentY = 0;
    private float currentX = 0;
    private int width, height;

    private int lineWidth = 0, lineHight;

    private int type;

    private String year;

    private int saveX, saveY, saveWidth, saveHeight;

    private float ratio;

    private ObjectAnimator objectAnimatorX;
    private ObjectAnimator objectAnimatorY;
    private AnimatorSet animatorSet;


    private boolean isBigState=false;
    public TimePumpingEntity(Context mContext, TimePumpingView layout) {
        this.mContext = mContext;
        offsetHeight = Utils.dip2px(mContext, 80);
        Bitmap bitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.img_time_down);
        Bitmap bitmap1 = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.img_time_up);
        ratio = (bitmap1.getHeight() + bitmap.getHeight() / 2) / (float) (bitmap.getHeight() + bitmap1.getHeight());
//        ratio = 0.7f;
        width = bitmap.getWidth();
        height = bitmap.getHeight();
        imgWidth = width / 8;
        imgHeight = height / 8;
        initX = Utils.getDisplayWidth(mContext) / 2 - imgWidth / 2;
        initY = offsetHeight - imgHeight;
        screenWidth = Utils.getDisplayWidth(mContext);
        screenHeight = Utils.getDisplayHeight(mContext);
        saveWidth = imgWidth;
        saveHeight = imgHeight;
        lineWidth = screenWidth / 15;
        lineHight = Utils.dip2px(mContext, 5);
        this.layout = layout;

         objectAnimatorX = ObjectAnimator.ofFloat(imageView,"scaleX",1.0f,2.0f);
         objectAnimatorY = ObjectAnimator.ofFloat(imageView, "scaleY", 1.0f, 2.0f);
        animatorSet = new AnimatorSet();

    }

    private View imageView;
    private TextView titleText, contentText, timeText;
    private TextView txt1, txt2;

    public void createView(int type) {
        switch (type) {
            case TYPE_LINE:
                imageView = LayoutInflater.from(mContext).inflate(R.layout.time_line_layout, null);
                txt1 = (TextView) imageView.findViewById(R.id.txt1);
                txt2 = (TextView) imageView.findViewById(R.id.txt2);
                txt1.setText(year);
                txt2.setText(year);
                break;
            case TYPE_IMAGE:
//                imageView = LayoutInflater.from(mContext).inflate(R.layout.time_item_layout, null);
                imageView = new TImeItemView(mContext);
                titleText = (TextView) imageView.findViewById(R.id.text_title);
                timeText = (TextView) imageView.findViewById(R.id.text_time);
                contentText = (TextView) imageView.findViewById(R.id.text_content);
                imageView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Toast.makeText(mContext, "点击了", Toast.LENGTH_SHORT).show();
                        if(currentY<screenHeight/5*3&&(imageView.getTag()==null||!(boolean)imageView.getTag())){
                            moveAnimation();
                        }else{
                            startEnlargeAnimation();
                        }


                    }
                });

                break;
        }
        RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(saveWidth, saveHeight);
        imageView.setLayoutParams(params);
        imageView.setAlpha(0f);

//        imageView.setOnTouchListener(new View.OnTouchListener() {
//            @Override
//            public boolean onTouch(View v, MotionEvent event) {
//                Log.e("tag","setOnTouchListener");
//                return false;
//            }
//        });
    }

    private float lastMove;

    public int getHeight() {
        return offsetHeight - imgHeight;
    }

    public void setImageViewParams(float moveY, int angle) {

        if ((currentY + moveY - (offsetHeight - imgHeight)) > 0 && (currentY + moveY - (offsetHeight - imgHeight)) < screenHeight) {

            maxY = -1;

            if (imageView == null) {
                createView(type);
                if (lastMove - moveY < 0)
                    layout.addView(imageView, 0);
                else
                    layout.addView(imageView);
            }
            switch (type) {
                case TYPE_LINE:
                    changeLine(moveY);
                    break;
                case TYPE_IMAGE:
                    changeImage(moveY, angle);
                    break;
            }

        } else {
//            Log.e("tag", "销毁中");
            if (imageView != null) {
//                currentY = currentY + moveY;
                if (moveY > 0)
                    maxY = 10;
                layout.removeView(imageView);
                imageView = null;
            }
//            Log.e("tag", "setImageViewParams2");
        }
        lastMove = moveY;
    }

    private void changeLine(float moveY) {

        maxY = 0;
        currentX = screenWidth / 2;
        ViewGroup.LayoutParams params = imageView.getLayoutParams();
        float scale = params.width / (float) width;
        imageView.setX((float) (currentX - (currentY + moveY) * Math.tan(Math.PI * (60 / 180.0f))));
        imageView.setY(currentY + moveY - params.height / 2);
        float size = ((currentY + moveY) / screenHeight) * 25;
        txt1.setTextSize(size);
        txt2.setTextSize(size);
        params.height = ViewGroup.LayoutParams.WRAP_CONTENT;
        params.width = (int) (screenWidth - imageView.getX() * 2);
        imageView.requestLayout();
        if (currentY + moveY < screenHeight / 4) {
            float alpha = (currentY + moveY) / (screenHeight / 2.5f);
            imageView.setAlpha(alpha);
        } else if (currentY + moveY < screenHeight / 3) {
            imageView.setAlpha(1f);
        } else {
            float alpha = 1.0f - (currentY + moveY - screenHeight / 3) / (screenHeight / 3);
            imageView.setAlpha(alpha);
        }
    }

    private void changeImage(float moveY, float angle) {
        if (moveY + currentY - offsetHeight <= 0)
            return;
        ViewGroup.LayoutParams params = imageView.getLayoutParams();
        float scale = 1;
        saveWidth = (int) (imgHeight * (1 + (imageView.getY() - offsetHeight + imgWidth) / Utils.dip2px(mContext, 26)));
        saveHeight = (int) (imgHeight * (1 + (imageView.getY() - offsetHeight + imgHeight) / Utils.dip2px(mContext, 14)));
        params.height = (int) (imgHeight * (1 + (moveY + currentY - offsetHeight) / Utils.dip2px(mContext, 14)));
        params.width = (int) (imgWidth * (1 + (moveY + currentY - offsetHeight) / Utils.dip2px(mContext, 26)));

        float scaleSize = ((currentY + moveY - offsetHeight / 3) / screenHeight);

        Log.e("tag", "scaleSize=" + scaleSize * 25);
        titleText.setTextSize(scaleSize * 20);
        titleText.setPadding((int) (scaleSize * 30), (int) (scaleSize * 20), 0, 0);


        timeText.setTextSize(scaleSize * 14);
        timeText.setPadding((int) (scaleSize * 30), 0, 0, (int) (scaleSize * 10));

        contentText.setTextSize(scaleSize * 14);
        contentText.setPadding((int) (scaleSize * 30), (int) (scaleSize * 10), 0, 0);
        imageView.requestLayout();

        float y = (currentY + moveY) * scale - params.height * ratio;
        currentX = screenWidth / 2 - (float) ((currentY + moveY - offsetHeight) * scale * Math.tan(Math.PI * (angle / 180.0f))) - params.width / 2;

        imageView.setX(currentX);
        imageView.setY(y);

        if (currentY + moveY < screenHeight / 4 + Utils.dip2px(mContext, 20)) {
//            float alpha = (currentY + moveY) / (screenHeight / 3f);

            float alpha = (currentY + moveY - screenHeight / 4) / (Utils.dip2px(mContext, 20) * 1f);
            imageView.setAlpha(alpha);
            Log.e("tag", "alpha=" + alpha);
        } else if (currentY + moveY > screenHeight / 3 && currentY + moveY < screenHeight * 3 / 5) {
            imageView.setAlpha(1f);
        } else {
            float alpha = 1.0f - (currentY + moveY - screenHeight * 3 / 5) / (screenHeight / 5);

            imageView.setAlpha(alpha);
        }

        contentText.setText("test");
        imageView.setClickable(true);

    }


    public void setType(int type) {
        this.type = type;
    }

    public void init(int y) {
        currentY = y;
    }

    public void setCurrentY(float moveY) {
        this.currentY = currentY + moveY;
    }

    public float getX() {
        return imageView == null ? 0 : imageView.getX();
    }

    public float getY() {
        return imageView == null ? 0 : imageView.getY();
    }

    public void setYear(String year) {
        this.year = year;
    }


    public float getMaxY() {
        return maxY;
    }



    /**
     * 事件 放大，缩小 动画
     * */
    protected void startEnlargeAnimation(){
        if(!animatorSet.isRunning()){
            if(imageView.getTag()!=null&&(boolean)imageView.getTag()){
                objectAnimatorX = ObjectAnimator.ofFloat(imageView,"scaleX",2.0f,1.0f);
                objectAnimatorY = ObjectAnimator.ofFloat(imageView, "scaleY", 2.0f, 1.0f);
                imageView.setTag(false);
            }else{
                objectAnimatorX = ObjectAnimator.ofFloat(imageView,"scaleX",1.0f,2.0f);
                objectAnimatorY = ObjectAnimator.ofFloat(imageView, "scaleY", 1.0f, 2.0f);
                imageView.setTag(true);
            }

            animatorSet.setDuration(2000);
            animatorSet.playTogether(objectAnimatorX, objectAnimatorY);
            animatorSet.start();

        }
    }


    protected void moveAnimation(){
       final float moveDistance = screenHeight/5*3-currentY;
        ValueAnimator valueAnimator = ValueAnimator.ofFloat(0.0F,1.0F);
        valueAnimator.setDuration(1000);
        valueAnimator.setInterpolator(new LinearInterpolator());
        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                layout.pointMove(moveDistance * (float) animation.getAnimatedValue(), true);
            }
        });
        valueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                layout.pointUp(currentY,moveDistance,true);
                startEnlargeAnimation();
            }
        });
        valueAnimator.start();
    }

}

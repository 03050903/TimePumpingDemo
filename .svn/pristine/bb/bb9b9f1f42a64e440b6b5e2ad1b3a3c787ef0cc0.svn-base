package com.jusfoun.timepumpingdemo;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ValueAnimator;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.animation.DecelerateInterpolator;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.List;

/**
 * Author  wangchenchen
 * CreateDate 2016/1/12.
 * Email wcc@jusfoun.com
 * Description
 */
public class CustomeScrollView extends View {
    private Context context;
    private float currentY = 0, moveY;
    private float downY;
    private Paint paint, graduationPaint, textPaint;

    private int width;
    private int scale = 1;
    private int y = 0, screenHeight, screenWidth;
    private List<Rect> points;
    private int radius;
    private int clickCount = -1;

    private Bitmap bitmap;
    private int lineCount;//长度
    private int mMaximumVelocity;
    private VelocityTracker mVelocityTracker;

    public CustomeScrollView(Context context) {
        super(context);
        initView(context);
    }

    public CustomeScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        initView(context);
    }

    public CustomeScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initView(context);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        screenWidth = w;
        Log.e("size", "w==" + w + "\nh==" + h);
        y = h / 2;
        screenHeight = h;


    }

    private void initView(Context context) {
        this.context = context;
        width = Utils.dip2px(context, 80);
        paint = new Paint();
        paint.setColor(Color.RED);
        paint.setAntiAlias(true);

        graduationPaint = new Paint();
        graduationPaint.setColor(Color.WHITE);
        graduationPaint.setAntiAlias(true);
        graduationPaint.setStrokeWidth(1);


        textPaint = new Paint();
        textPaint.setColor(Color.WHITE);
        textPaint.setAntiAlias(true);
        textPaint.setTextSize(30);


        points = new ArrayList<>();

        radius = Utils.dip2px(context, 5);

        bitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.img_biaoji);
        mMaximumVelocity = ViewConfiguration.get(context).getScaledMaximumFlingVelocity();
    }


    public void refresh(int count) {
        lineCount = width * count;
        int index = points.size();
        for (int i = index; i < index + count; i++) {
//            if (scale >= 3)
//                scale = 1;
            Rect rect = new Rect();
            if (i == 0)
                rect.set(width, 0, width, Utils.dip2px(context, 50));
            else {
                rect.set(points.get(i - 1).right + width, 0, points.get(i - 1).right + width, Utils.dip2px(context, 50));
            }
            points.add(rect);
            scale++;
        }
    }

    public int getClickCount(int x, int y) {
        for (int i = 0; i < points.size(); i++) {
            Rect rect = points.get(i);
            if (rect.left + currentY + moveY <= x
                    && rect.right + currentY + moveY >= x
                    && rect.top <= y
                    && rect.bottom >= y) {
                return i;
            }
        }
        return -1;
    }

    private boolean isMove = false;
    private boolean isDoublePoint = false;

    @Override
    public boolean onTouchEvent(MotionEvent event) {

        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(event);
        if (event.getPointerCount() >= 2) {
            isDoublePoint = true;
            return true;
        }
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                downY = event.getX();
                isMove = false;
                isDoublePoint = false;
                clickCount = getClickCount((int) (event.getX()), (int) event.getY());
                break;
            case MotionEvent.ACTION_MOVE:
                if (isDoublePoint)
                    break;
                /*************超出后禁止滑动***************/
                /**
                 * 第一个点向左滑出屏幕或者最好一个点向右滑出屏幕禁止滑动
                 */
                if (event.getX() - downY > 0) {
                    if (points.get(0).left + currentY + event.getX() - downY > screenHeight) {
                        listener.setCanMove(false);
                        return true;
                    }
                } else {
                    if (points.get(points.size() - 1).right + currentY + event.getX() - downY < 0) {
                        listener.setCanMove(false);
                        return true;
                    }

                }
                listener.setCanMove(true);
                /*************超出后禁止滑动***************/
                moveY = event.getX() - downY;
                Log.e("tag", "currentY + moveY=" + (currentY + moveY));
                pointMove(moveY, true);

                break;
            case MotionEvent.ACTION_UP:
                if (clickCount != -1 && !isMove) {
                    Toast.makeText(context, "第" + clickCount + "个点", Toast.LENGTH_SHORT).show();
                    //点击跳转
                    if (listener != null) {
//                        listener.touchMove(moveY-clickCount*Utils.dip2px(context,60));
//                        listener.touchUp(currentY,moveY-clickCount*Utils.dip2px(context,60));
                    }
                }
                mVelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);


                // TODO 暂时屏蔽惯性
//                if (Math.abs(moveY) > 50 && Math.abs(mVelocityTracker.getYVelocity()) > 1000) {
////                    handler.sendEmptyMessage(100);
//                    if (moveY < 0) {
//                        inertiaAnimation(true);
//                    } else {
//                        inertiaAnimation(false);
//                    }
//                } else {
//                    pointUp(currentY, moveY, true);
//                }

                pointUp(currentY, moveY, true);
                listener.setCanMove(true);
                break;
        }
        return true;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        canvas.drawColor(Color.parseColor("#00000000"));
        for (int i = 0; i < points.size(); i++) {
            Rect rect = points.get(i);
//            canvas.drawCircle(rect.left / 2 + rect.right / 2 + currentY + moveY, rect.top / 2 + rect.bottom / 2, radius, paint);
            canvas.drawBitmap(bitmap, rect.left + currentY + moveY, screenHeight / 2, paint);
        }
        for (int i = 0; i < (lineCount + screenWidth) / Utils.dip2px(context, 5); i++) {

            float startX = Utils.dip2px(context, 5) * (i + 1);
            float startY = screenHeight - Utils.dip2px(context, 7);
            if (i % 5 == 0) {
                startY = screenHeight - Utils.dip2px(context, 14);
            }
            canvas.drawLine(startX + currentY + moveY, startY, startX + currentY + moveY, screenHeight, graduationPaint);

        }
        for (int i = 1; i <= 6; i++) {
            canvas.drawText("201" + i, 3 * i * width + currentY + moveY, 40, textPaint);
        }
        canvas.restore();
    }

    public void pointUp(float currentY, float moveY, boolean isHasListener) {
        if (listener != null && isHasListener)
            listener.touchUp(currentY, moveY);
        this.currentY = currentY + moveY;
        this.downY = 0;
        this.moveY = 0;
        postInvalidate();

    }

    public void pointMove(float moveY, boolean isHasListener) {
        setCan();
        if (Math.abs(moveY) > 10) {
            isMove = true;
            this.moveY = moveY;
            postInvalidate();
            if (listener != null && isHasListener) {
                listener.touchMove(moveY);
            }
        }
    }


    protected void setCan(){
        Log.e("tag","setCan1");
        if (moveY > 0) {
            if (points.get(0).left + currentY + moveY > screenHeight) {
                Log.e("tag","setCan2");
                listener.setCanMove(false);
            }else{
                Log.e("tag","setCan3");
                listener.setCanMove(true);
            }
        } else {
            if (points.get(points.size() - 1).right + currentY + moveY < 0) {
                Log.e("tag","setCan4");
                listener.setCanMove(false);
            }else{
                Log.e("tag","setCan5");
                listener.setCanMove(true);
            }

        }
    }

    private OnScrollTouchListener listener;

    public void setListener(OnScrollTouchListener listener) {
        this.listener = listener;
    }

    public interface OnScrollTouchListener {
        void touchUp(float currentY, float moveY);

        void touchMove(float moveY);

        void setCanMove(boolean canMove);
    }

    public void setCurrentY(int currentY) {
        this.currentY = currentY;
    }


    protected void inertiaAnimation(final boolean isUp) {
        ValueAnimator animator = ValueAnimator.ofFloat(0f, 30f);
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {

                if (!isUp) {
                    pointMove(moveY + (float) animation.getAnimatedValue(), true);
                    moveY = moveY + (float) animation.getAnimatedValue();
                } else {
                    pointMove(moveY - (float) animation.getAnimatedValue(), true);
                    moveY = moveY - (float) animation.getAnimatedValue();
                }
            }

        });
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                pointUp(currentY, moveY, true);
            }
        });
        animator.setInterpolator(new DecelerateInterpolator());
        animator.setDuration(400);
        animator.start();
    }


}
